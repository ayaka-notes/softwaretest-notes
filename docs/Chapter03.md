---
sidebar_position: 3
title: 第03章 测试理论和方法
---

## 第03章 测试理论和方法

![](Chapter02.assets/截屏2023-05-19%2012.40.32.png)


### 一、静态测试

> 比如说你看到一个到一段代码是吧？比如说 1 + 1 = 2，然后你就自己给他一个输入1，另外一个是也是1，程序在脑子里面跑一遍。模拟运行。

#### 1.1 code walkthrough

-   不运行程序，测试者使用工具评估、分析特定的程序
-   静态测试不运行程序，但是依然有测试样例，预期的结果！
-   测试会把测试的数据带入到程序里面，按照逻辑来一行一行模拟运行，但是不运行程序
-   如何按照逻辑模拟运行的结果和预期不符合，说明发现了错误
-   不运行程序节省了代价和开销、等相关的成本

目标：

-   walk through 团队的目标是检测故障，而不是纠正故障。
-   引导walk through 的人员指导团队其他成员完成代码。
-   walk through 可以由团队成员编写的问题列表或代码本身驱动，团队成员可以在适当的时候提出他们的担忧。
-   在这两种情况下，每个问题都将在出现时进行讨论，并将其解决为需要解决的故障或将在讨论中消除的混淆点

#### 1.2 Inspection

-   相比较walk-throught，Inspection就是审查，相对来说更加正式。
-   组成人数大概4-6人

### 二、动态测试

动态测试是基于执行程序本身的一种测试，使用测试用例，然后从程序中获得运行结果。按照是否查看源代码，分为黑盒和白盒测试。

-   白盒：查看源代码，要根据代码测试逻辑是否正确
-   黑盒：根据测试需求规则说明，程序是否按照规则说明来运行（黑盒不要去看源代码）

#### 2.1 黑盒测试

-   Equivalence testing
-   Boundary value analysis

#### 2.2 白盒测试

-   逻辑驱动、或者说路径测试
-   需要查看源代码，根据源代码确定路径
-   测试每一个路径通过代码区域

> 为什么需要白盒测试：
> 因为黑盒测试它是不完备，它很多错误发现不了。有一些错误是是在程序的逻辑里面，这个程序逻辑里面是有很复杂的依赖关系以后才能触发，但是黑盒测试是完全发现不了这类问题。白盒测试更能发现里面隐性的错误，这也是软件测试多年以来越来越重视白盒测试的原因，


#### 2.3 灰盒测试

- 结合白盒和黑盒的方法

#### 2.4 测试的类型
类型：
-   语句覆盖：确保每个语句至少被执行了一次
-   分支覆盖：又称判定覆盖，是指使得程序中每个判断的取真分支和取假分支至少经历一次，即判断的真假均曾被满足。
-   路径覆盖：确保每个不同的路径至少被测试了一次

![](Chapter02.assets/截屏2023-05-19%2013.15.20.png)

- 如上图所示，分支覆盖只需要两个测试用例，$(A=2,B=0)$ $(A=0,B=1)$ 
	- 对于点a，需要 $A>0,A\leq0$，$B=0,B\neq0$
	- 对于点b，需要$A=2,A\neq2$，$X>1,X\leq1$
- 路径覆盖：$2\times 2$，每个分支有两个选择。拓扑路径就 4 个，
- 判断覆盖（条件覆盖）：需要覆盖到每个一个判断的结果，上面a点有两个判断，b点也有两个判断，总共四个判断，也就是2的四次方16。


### 三、单元测试

- 单元测试本身它就是在软件开发阶段去定义的，单元测试经常是软件开发工程师里面需要去伴随着去做的一些测试的过程。


### 四、其他测试

#### 4.1 回归测试

- 迭代开发过程，一轮迭代了 10 个版本。 10 个版本我不能每次都做测试，我不能每次把所有测试都跑一遍，回归测试来减少测试工作量。

#### 4.2 冒烟测试

- 给出一些有害的输入，检测能不能处理

#### 4.3 随机测试

- 随机生成很多测试的样本，然后测试

#### 4.4 数据流测试

- 根据定义使用的路径测试

#### 4.5 变异测试

- 人为的加入一些错误，产生程序的变异体。
- 然后评估测试用例的是不是全面有效的



### 五、验证

- 另外还有一类这非常特殊的，这一类叫做验证，有的地方不他不把它归到测试
- 特别是对我们很多叫做安全关键系统的话，现在很多都有验证的
- 我可以有这种迭代式的证明的方法，怎么证明？一步一步的按照每一步它有什么样的变量？按照这种变量的迭代关系去证明它最终的结果就是这个通用的一个，通用的一个正确的结果，这是一个验证过程！



